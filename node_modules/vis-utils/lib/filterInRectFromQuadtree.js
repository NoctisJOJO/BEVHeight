'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = filterInRectFromQuadtree;

var _rectContains = require('./rectContains');

var _rectContains2 = _interopRequireDefault(_rectContains);

var _rectIntersects = require('./rectIntersects');

var _rectIntersects2 = _interopRequireDefault(_rectIntersects);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Filters the elements in the passed in quadtree to those that are contained within
 * the specified rectangle.
 *
 * @param {Object} quadtree The input data as a d3-quadtree to filter
 * @param {Number[][]} rect The rectangle, a pair of two points [[x, y], [x, y]]
 * @param {Function} x Function that maps a point in the array to its x value
 *   (defaults to d => d[0])
 * @param {Function} y Function that maps a point in the array to its y value
 *   (defaults to d => d[1])
 *
 * @return {Array} The subset of the input data that is contained within the
 *   rectangle
 */
function filterInRectFromQuadtree(quadtree, rect) {
  var x = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (d) {
    return d[0];
  };
  var y = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function (d) {
    return d[1];
  };

  var filtered = [];
  quadtree.visit(function (node, x1, y1, x2, y2) {
    // check that quadtree node intersects
    var overlaps = (0, _rectIntersects2.default)(rect, [[x1, y1], [x2, y2]]);

    // skip if it doesn't overlap the brush
    if (!overlaps) {
      return true;
    }

    // if this is a leaf node (node.length is falsy), verify it is within the brush
    // we have to do this since an overlapping quadtree box does not guarantee
    // that all the points within that box are covered by the brush.
    if (!node.length) {
      var d = node.data;
      if ((0, _rectContains2.default)(rect, [x(d), y(d)])) {
        filtered.push(d);
      }
    }

    // return false so that we traverse into branch (only useful for non-leaf nodes)
    return false;
  });

  return filtered;
}